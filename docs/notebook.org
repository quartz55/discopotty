#+TITLE: discopotty dev notebook

Link for base permissions invite:
[[https://discord.com/oauth2/authorize?client_id=235863322304577537&permissions=2184441408&scope=bot][boop]]

* DOING Music Player
** TODO Replace external ffmpeg/ffprobe process with libav
- Will this be a PITA because of all the needed codecs
when building? /probably/
- Is it worth it? /no/ (maybe it's actually worse given that ocaml-multicore isn't here yet üòø)
- Is it fun? /yeah/ üòù

** DOING youtube-dl support
*** DOING Seamless caching
This is relatively simple to do given that youtube-dl already
generates unique ids for each track.

** TODO Custom ytdl-like implementation
I reckon this is really only worth it if we do the libav thing.

** DOING Player abstraction
*** DONE Make an actual ~Audio_stream~ type

-------

* TODO Cache layer
Is it worth using something like [[https://github.com/mirage/irmin][Irmin]] here?

-------

* TODO Persistance layer
I'm inclined towards a sqlite+caqti based approach

-------

* TODO Transport-level zlib compression

-------

* TODO Message builder
Ideas list:
- /(G)ADT/
    Later can refactor into a (G)ADT type for automatic
    building of the other different message types[fn:msg_type_ref]:
        - [ ] Default
        - [ ] Reply

[fn:msg_type_ref] Reference: https://discord.com/developers/docs/resources/channel#message-object-message-types

** DONE Custom format handler
Using semantic tags: ~"@{<b>bold @{<i>bold_italic@}@} @{<i>italic@} @{<v>code@}"~
** DONE Utils
Just a little helper to make it easier to build valid stylized messages

---------

* DOING Rate Limiting
** DONE Internal token bucket implementation
** TODO HTTP
As per [[https://discord.com/developers/docs/topics/rate-limits][the docs]],
these are the headers:

- *X-RateLimit-Global*
#+BEGIN_QUOTE
    Returned only on a HTTP 429 response if the rate limit headers returned are
    of the global rate limit (not per-route)
#+END_QUOTE

- *X-RateLimit-Limit*
#+BEGIN_QUOTE
    The number of requests that can be made
#+END_QUOTE

- *X-RateLimit-Remaining*
#+BEGIN_QUOTE
    The number of remaining requests that can be made
#+END_QUOTE

- *X-RateLimit-Reset*
#+BEGIN_QUOTE
    Epoch time (seconds since 00:00:00 UTC on January 1, 1970) at which the rate
    limit resets
#+END_QUOTE

- *X-RateLimit-Reset-After*
#+BEGIN_QUOTE
    Total time (in seconds) of when the current rate limit bucket will reset.
    Can have decimals to match previous millisecond ratelimit precision
#+END_QUOTE

- *X-RateLimit-Bucket*
#+BEGIN_QUOTE
    A unique string denoting the rate limit being encountered
    (non-inclusive of major parameters in the route path)
#+END_QUOTE

---------

* TODO HTTP API implementation
Doesn't have to be fully done, just comprehensive enough for now.

---------

* DOING Test framework
Alcotest + QCheck üëç
